Q1. Text files and binary files differ in how they store and interpret data. Text files contain human-readable characters encoded using a specific character encoding, such as ASCII or UTF-8. They store textual information, including letters, numbers, symbols, and newline characters. Binary files, on the other hand, store data in a binary format, representing information in the form of bytes. They can store any type of data, including text, images, audio, video, or serialized objects, and they are not directly human-readable.

Q2. Text files are typically a better option when working with plain text data that needs to be human-readable or processed as text, such as configuration files, log files, or source code. They allow easy editing with text editors and support operations like searching, parsing, and manipulating text. Binary files are useful when working with complex data structures, such as images, audio files, or serialized objects. They preserve the internal structure and can efficiently store and retrieve binary data without requiring character encoding or newline handling.

Q3. When using binary operations to read and write a Python integer directly to disk, some issues may arise. One issue is endianness, which refers to the byte order in which the integer is stored. Different systems have different byte orders, and reading or writing an integer in the wrong byte order can lead to incorrect interpretation of the data. Another issue is portability, as the binary representation of integers may vary across platforms, making it challenging to read or write integers in a consistent manner across different systems.

Q4. Using the `with` keyword in Python provides a benefit over explicitly opening a file by automatically handling the file's opening and closing. The `with` statement ensures that the file is properly closed after its block is executed, even if an exception occurs. It eliminates the need for explicit `file.close()` calls and helps prevent resource leaks and file corruption. It promotes cleaner and more readable code by encapsulating the file operations within a well-defined scope.

Q5. When reading a line of text in Python, by default, it includes the trailing newline character (`\n`). You can use the `rstrip()` method to remove the trailing newline if desired. When writing a line of text, Python does not automatically append a newline character. It is the responsibility of the programmer to add the newline character (`\n`) explicitly if needed.

Q6. Random-access operations are enabled by file operations like `seek()` and `tell()`. `seek(offset, whence)` allows you to move the file pointer to a specific position indicated by the offset, while `tell()` returns the current position of the file pointer. With these operations, you can navigate to different parts of a file and perform read or write operations at specific positions.

Q7. The `struct` package in Python is most commonly used when working with binary data that follows a specific structure or format. It allows you to pack and unpack binary data into Python objects based on a predefined format string. This package is useful for tasks like parsing binary file formats, working with network protocols, or interacting with low-level binary data.

Q8. Pickling is a suitable option when you need to serialize and deserialize Python objects, preserving their state and structure. It is commonly used for storing and retrieving complex data structures, sharing data between different Python programs, or implementing caching mechanisms. Pickling allows you to convert objects into a binary representation that can be saved to a file or transferred over a network, and later restored to their original form.

Q9. The `shelve` package is best used when you need persistent storage for Python objects, similar to a dictionary. It provides a simple way to store and retrieve objects by associating them with unique keys. `shelve` uses a file-based database format, allowing you to

 persistently store and access objects across multiple program executions. It is useful when you need a lightweight and easy-to-use solution for basic data storage and retrieval.

Q10. A special restriction when using the `shelve` package is that the keys used to access the stored objects must be strings. `shelve` internally uses the keys as dictionary keys, and dictionaries in Python require string keys. If you try to use a key of a different type, such as an integer or a tuple, it will result in a `TypeError`. Therefore, when using `shelve`, it's important to ensure that the keys you use for accessing objects are strings or can be converted to strings.